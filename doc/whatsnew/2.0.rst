**************************
  What's New In Pylint 2.0
**************************

:Release: 2.0
:Date: |TBA|

Summary -- Release highlights
=============================

* Dropped support for Python 2. This release will work only on Python 3.4+.

  If you need to use `pylint` on Python 2, you can use Pylint 1.8. We'll continue
  to do bug releases until 2020, when Python 2 goes officially EOL.
  `pylint` will still be able to analyze Python 2 files, but some checks might not work
  as they will assume that their running environment was Python 2.

* Given the dropping of Python 2, the Python 3 porting mode (enabled via `--py3k`) can now
  also run with Python 3.

  The porting mode used to be a no-op on Python 3, but most of the messages can now be emitted
  when the running interpreter is Python 3. The only messages that won't be emitted are those that
  rely on a particular syntax specific to Python 2, for instance `print` as a statement.


New checkers
============
* A new check was added, ``comparison-with-itself``.

  This refactoring message is emitted when a variable is compared against itself.

  .. code-block:: python

    if variable == variable:  # bad
        pass

* A new check was added, ``consider-using-in``.

  This refactoring message is emitted when a variable is compared against multiple
  values concatenated by ors instead of using the faster, more idiomatic "in" check.

  .. code-block:: python

    if variable == 1 or variable == 2 or variable == 3:  # bad
        pass

    if variable in (1, 2, 3):  # good
        pass

* A new check was added, ``consider-using-join``.

  This refactoring message is emitted when using a for loop over a iterable to join strings
  instead of the faster, less memory consuming and more idiomatic str.join(sequence).

  .. code-block:: python

    result = ''  # bad
    for number in ['1', '2', '3']:
        result += number

    result = ''.join(['1', '2', '3'])  # good

* New ``useless-return`` message when function or method ends with a "return" or
  "return None" statement and this is the only return statement in the body.

* New ``use-symbolic-message-instead`` message when a message is activated or
  deactivated by id instead of symbol.
  The use of symbol is more explicit and easier to remind.

* A new check was added, ``consider-swap-variables``.

  This refactoring message is emitted when using a temporary variable in order
  to swap the values of two variables instead of the shorter, more idiomatic
  approach with tuple-unpacking.

  Instead of a temporary variable, the one-line syntax with commas should be used.

  See http://docs.python-guide.org/en/latest/writing/style/ or
  http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#swap-values
  for details.

  .. code-block:: python

     temp = a  # the wrong way
     a = b
     b = temp

     a, b = b, a  # the right way

* Two new checks, `invalid-envvar-value` and `invalid-envvar-default`, were added.

  The former is trigger whenever pylint detects that environment variable manipulation
  functions uses a different type than strings, while the latter is emitted whenever
  the said functions are using a default variable of different type than expected.

* A new check was added, `subprocess-popen-preexec-fn`,

  This refactoring message is emitted when using the keyword argument preexec_fn
  when creating subprocess.Popen instances which may be unsafe when used in
  the presence of threads.

  See `subprocess.Popen <https://docs.python.org/3/library/subprocess.html#popen-constructor>`_
  for full warning details.

* New ``try-except-raise`` message when an except handler block has a bare
  `raise` statement as its first operator or the exception type being raised
  is the same as the one being handled.

*  New `possibly-unused-variable` check added.

  This is similar to `unused-variable`, the only difference is that it is
  emitted when we detect a locals() call in the scope of the unused variable.
  The `locals()` call could potentially use the said variable, by consuming
  all values that are present up to the point of the call. This new check
  allows to disable this error when the user intentionally uses `locals()`
  to consume everything.

  For instance, the following code will now trigger this new error:

  .. code-block:: python

     def func():
         some_value = some_call()
         return locals()

* New `unhashable-dict-key` check added to detect dict lookups using
  unhashable keys such as lists or dicts.

* New `self-cls-assignment` warning check added.

  This is warning if the first argument of an instance/ class method gets
  assigned

  .. code-block:: python

     class Foo(object):
         def foo(self, bar):
             self = bar

* New verbose mode option `--verbose` to display of extra non-checker-related output. Disabled by default.

Other Changes
=============

* Fix a false positive ``inconsistent-return-statements`` message when if
  statement is inside try/except.

* Fix a false positive ``inconsistent-return-statements`` message when
  `while` loop are used.

* Fix emission of false positive ``no-member`` message for class with
  "private" attributes whose name is mangled.

* Fix ``unused-argument`` false positives with overshadowed variable in dictionary comprehension.

* Fixing false positive ``inconsistent-return-statements`` when
  never returning functions are used (i.e such as sys.exit).

* Fix false positive ``inconsistent-return-statements`` message when a
  function is defined under an if statement.

* Fix false positive ``inconsistent-return-statements`` message by
  avoiding useless exception inference if the exception is not handled.

* Fix false positive ``undefined-variable`` for lambda argument in
    class definitions

* Suppress false-positive ``not-callable`` messages from certain staticmethod descriptors

* `singleton-comparison` will suggest better boolean conditions for negative conditions.

* `undefined-loop-variable` takes in consideration non-empty iterred objects before emitting.

  For instance, if the loop iterable is not empty, this check will no longer be emitted.

* Enum classes no longer trigger `too-few-methods`

* Special methods now count towards `too-few-methods`,
  and are considered part of the public API.
  They are still not counted towards the number of methods for
  `too-many-methods`.

* docparams allows abstract methods to document returns documentation even
  if the default implementation does not return something.
  They also no longer need to document raising a NotImplementedError.

* Skip wildcard import check for `__init__.py`.

* Don't warn 'useless-super-delegation' if the subclass method has different type annotations.

* Don't warn that a global variable is unused if it is defined by an import

  .. code-block:: python

    def func():
        global sys
        import sys
