**************************
  What's New In Pylint 2.0
**************************

:Release: |release|
:Date: |TBD|


Summary -- Release highlights
=============================

* None yet.


New checkers
============

* We added a new check, ``literal-comparison``, which is used
  whenever **pylint** can detect a comparison to a literal. This is usually
  not what we want and, potentially, error prone. For instance, in the given example,
  the first string comparison returns true, since smaller strings are interned
  by the interpreter, while for larger ones, it will return False::

       mystring = "ok"
       if mystring is "ok": # Returns true
           # do stuff

       mystring = "a" * 1000
       if mystring is ("a" * 1000): # This will return False
           # do stuff

  Instead of using the ``is`` operator, you should use the ``==`` operator for
  this use case.


* We added a new refactoring message, 'consider-merging-isinstance', which is
  emitted whenever we can detect that consecutive *isinstance* calls can be merged
  together.
  For instance, in this example, we can merge the first two *isinstance* calls::

      $ cat a.py
      if isinstance(x, int) or isinstance(x, float):
          pass
      if isinstance(x, (int, float)) or isinstance(x, str):
          pass
      $ pylint a.py
      R:  1, 0: Consider merging these isinstance calls to isinstance(x, (float, int)) (consider-merging-isinstance)
      R:  3, 0: Consider merging these isinstance calls to isinstance(x, (int, float, str)) (consider-merging-isinstance)

* A new error check was added, ``invalid-metaclass``, which is used whenever *pylint*
  can detect that a given class is using a metaclass which is invalid for the purpose
  of the class. This usually might indicate a problem in the code, rather than
  something done on purpose.

  .. code-block:: python

       # Needs to inherit from *type* in order to be valid
       class SomeClass(object):
           ...

       class MyClass(metaclass=SomeClass):
           pass

* A new warning was added, ``useless-super-delegation``, which is used whenever
  we can detect that an overridden method is useless, relying on *super()* delegation
  to do the same thing as another method from the MRO.

  For instance, in this example, the first two methods are useless, since they
  do the exact same thing as the methods from the base classes, while the next
  two methods are not, since they do some extra operations with the passed
  arguments.

  .. code-block:: python

      class Impl(Base):

          def __init__(self, param1, param2):
              super(Impl, self).__init__(param1, param2)
     
          def useless(self, first, second):
              return super(Impl, self).useless(first, second)

          def not_useless(self, first, **kwargs):
              debug = kwargs.pop('debug', False)
              if debug:
                  ...
              return super(Impl, self).not_useless(first, **kwargs)

          def not_useless_1(self, first, *args):
              return super(Impl, self).not_useless_1(first + some_value, *args)

* The warnings ``missing-returns-doc`` and ``missing-yields-doc`` have each
  been replaced with two new warnings - ``missing-[return|yield]-doc`` and
  ``missing-[return|yield]-type-doc``. Having these as separate warnings
  allows the user to choose whether their documentation style requires
  text descriptions of function return/yield, specification of return/yield
  types, or both.

  .. code-block:: python

      # This will raise missing-return-type-doc but not missing-return-doc
      def my_sphinx_style_func(self):
          """This is a Sphinx-style docstring.

          :returns: Always False
          """
          return False

      # This will raise missing-return-doc but not missing-return-type-doc
      def my_google_style_func(self):
          """This is a Google-style docstring.

          Returns:
              bool:
          """
          return False

* A new refactoring check was added, ``redefined-argument-from-local``, which is
  emitted when **pylint** can detect than a function argument is redefined locally
  in some potential error prone cases. For instance, in the following piece of code,
  we have a bug, since the check will never return ``True``, given the fact that we
  are comparing the same object to its attributes.

  .. code-block:: python

      def test(resource):
          for resource in resources:
              # The ``for`` is reusing ``resource``, which means that the following
              # ``resource`` is not what we wanted to check against.
              if resource.resource_type == resource:
                 call_resource(resource)

  Other places where this check looks are *with* statement name bindings and
  except handler's name binding.

Other Changes
=============

* ``arguments-differ`` check was rewritten to take in consideration
   keyword only parameters and variadics.

   Now it also complains about losing or adding capabilities to a method,
   by introducing positional or keyword variadics. For instance, *pylint*
   now complains about these cases::

       class Parent(object):

           def foo(self, first, second):
               ...

           def bar(self, **kwargs):
               ...

           def baz(self, *, first):
               ...

       class Child(Parent):

           # Why subclassing in the first place?
           def foo(self, *args, **kwargs):
               # mutate args or kwargs.
               super(Child, self).foo(*args, **kwargs)

           def bar(self, first=None, second=None, **kwargs):
               # The overridden method adds two new parameters,
               # which can also be passed as positional arguments,
               # breaking the contract of the parent's method.

           def baz(self, first):
               # Not keyword-only

* ``redefined-outer-name`` is now also emitted when a
  nested loop's target variable is the same as an outer loop.

  .. code-block:: python

      for i, j in [(1, 2), (3, 4)]:
          for j in range(i):
              print(j)

* relax character limit for method and function names that starts with ``_``.
  This will let people to use longer descriptive names for methods and
  functions with a shorter scope (considered as private). The same idea
  applies to variable names, only with an inverse rule: you want long
  descriptive names for variables with bigger scope, like globals.

* Add ``InvalidMessageError`` exception class and replace ``assert`` in
  pylint.utils with ``raise InvalidMessageError``.

* ``UnknownMessageError`` (formerly ``UnknownMessage``) and
  ``EmptyReportError`` (formerly ``EmptyReport``) are now provided by the new
  ``pylint.exceptions`` submodule instead of ``pylint.utils`` as before.

* We now support inline comments for comma separated values in the configurations

  For instance, you can now use the **#** sign for having comments inside
  comma separated values, as seen below::

      disable=no-member, # Don't care about it for now
              bad-indentation, # No need for this
              import-error

  Of course, interweaving comments with values is also working::

      disable=no-member,
              # Don't care about it for now
              bad-indentation # No need for this


  This works by setting the `inline comment prefixes`_ accordingly.

* Added epytext docstring support to the docparams extension.


Bug fixes
=========

* Fix a false positive of 'redundant-returns-doc', occurred when the documented
  function was using *yield* instead of *return*.

* Fix a false positive of 'missing-param-doc' and 'missing-type-doc',
  occurred when a class docstring uses the 'For the parameters, see'
  magic string but the class ``__init__`` docstring does not, or vice versa.

* Added proper exception type inference for 'missing-raises-doc'. Now:

  .. code-block:: python

      def my_func():
          """"My function."""
          ex = ValueError('foo')
          raise ex

  will properly be flagged for missing documentation of
  ``:raises ValueError:`` instead of ``:raises ex:``, among other scenarios.

* Fix false positives of ``missing-[raises|params|type]-doc`` due to not
  recognizing valid keyword synonyms supported by Sphinx.

* More thorough validation in ``MessagesStore.register_messages()`` to detect
  conflicts between a new message and any existing message id, symbol,
  or ``old_names``.


Removed Changes
===============

* ``pylint-gui`` was removed, because it was deemed unfit for being included
  in *pylint*. It had a couple of bugs and misfeatures, its usability was subpar
  and since its development was neglected, we decided it is best to move on without it.


* The HTML reporter was removed, including the ``--output-format=html`` option.
  It was lately a second class citizen in Pylint, being mostly neglected.
  Since we now have the JSON reporter, it can be used as a basis for building
  more prettier HTML reports than what Pylint can currently generate. This is
  part of the effort of removing cruft from Pylint, by removing less used
  features.

* The ``--files-output`` option was removed. While the same functionality cannot
  be easily replicated, the JSON reporter, for instance, can be used as a basis
  for generating the messages per each file.

* ``--required-attributes`` option was removed.

* ``--ignore-iface-methods`` option was removed.

* The ``--optimize-ast`` flag was removed.

  The option was initially added for handling pathological cases,
  such as joining too many strings using the addition operator, which
  was leading pylint to have a recursion error when trying to figure
  out what the string was. Unfortunately, we decided to ignore the
  issue, since the pathological case would have happen when the
  code was parsed by Python as well, without actually reaching the
  runtime step and as such, we decided to remove the error altogether.

* ``epylint.py_run``'s *script* parameter was removed.

  Now ``epylint.py_run`` is always using the underlying ``epylint.lint``
  method from the current interpreter. This avoids some issues when multiple
  instances of **pylint** are installed, which means that ``epylint.py_run``
  might have ran a different ``epylint`` script than what was intended.

.. _`inline comment prefixes`: https://docs.python.org/3/library/configparser.html#customizing-parser-behaviour
