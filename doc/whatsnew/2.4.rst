**************************
 What's New in Pylint 2.4
**************************

:Release: 2.4
:Date: TBA


Summary -- Release highlights
=============================


New checkers
============

* Added `unnecessary-comprehension` that detects unnecessary comprehensions.

  This check is emitted when ``pylint`` finds list-, set- or dict-comprehensions,
  that are unnecessary and can be rewritten with the list-, set- or dict-constructors.

  Close #2905

* Added `subprocess-run-check` to handle subprocess.run without explicitly set `check` keyword.

  Close #2848

* We added a new check message ``dict-iter-missing-items``.
  This is emitted when trying to iterate through a dict in a for loop without calling its .items() method.

  Closes #2761

* We added a new check message ``missing-parentheses-for-call-in-test``.
  This is emitted in case a call to a function is made inside a test but
  it misses parentheses.

* A new check ``class-variable-slots-conflict`` was added.

  This check is emitted when ``pylint`` finds a class variable that conflicts with a slot
  name, which would raise a ``ValueError`` at runtime.

  For example, the following would raise an error::

    class A:
        __slots__ = ('first', 'second')
        first = 1

* A new check ``preferred-module`` was added.

  This check is emitted when ``pylint`` finds an imported module that has a
  preferred replacement listed in ``preferred-modules``.

  For example, you can set the preferred modules as ``xml:defusedxml,json:ujson``
  to make ``pylint`` suggest using ``defusedxml`` instead of ``xml``
  and ``ujson`` rather than ``json``.

* A new extension ``broad_try_clause`` was added.

  This extension enforces a configurable maximum number of statements inside
  of a try clause. This facilitates enforcing PEP 8's guidelines about try / except
  statements and the amount of code in the try clause.

  You can enable this extension using ``--load-plugins=pylint.extensions.broad_try_clause``
  and you can configure the amount of statements in a try statement using
  ``--max-try-statements``.


Other Changes
=============

* ``len-as-condition`` now only fires when a ``len(x)`` call is made without an explicit comparison.

  The message and description accompanying this checker has been changed
  reflect this new behavior, by explicitly asking to either rely on the
  fact that empty sequence are false or to compare the length with a scalar.

  OK::

    if len(x) == 0:
      pass

    while not len(x) == 0:
      pass

    assert len(x) > 5, message

  KO::

    if not len(x):
      pass

    while len(x) and other_cond:
      pass

    assert len(x), message

* A file is now read from stdin if the ``--from-stdin`` flag is used on the
  command line. In addition to the ``--from-stdin`` flag a (single) file
  name needs to be specified on the command line, which is needed for the
  report.

* The checker for ungrouped imports is now more permissive.

The import can now be sorted alphabetically by import style.
This makes pylint compatible with isort.

The following imports do not trigger an ``ungrouped-imports`` anymore ::

    import unittest
    import zipfile
    from unittest import TestCase
    from unittest.mock import MagicMock

* The checker for missing return documentation is now more flexible.

The following does not trigger a ``missing-return-doc`` anymore ::

    def my_func(self):
        """This is a docstring.

        Returns
        -------
        :obj:`list` of :obj:`str`
            List of strings
        """
        return ["hi", "bye"] #@

* ``signature-mutators`` CLI and config option was added.

With this option, users can choose to ignore `too-many-function-args`, `unexpected-keyword-arg`,
and `no-value-for-parameter` for functions decorated with decorators that change
the signature of a decorated function.

For example a test may want to make use of hypothesis.
Adding `hypothesis.extra.numpy.arrays` to `signature_mutators`
would mean that `no-value-for-parameter` would not be raised for::

    @given(img=arrays(dtype=np.float32, shape=(3, 3, 3, 3)))
    def test_image(img):
        ...
